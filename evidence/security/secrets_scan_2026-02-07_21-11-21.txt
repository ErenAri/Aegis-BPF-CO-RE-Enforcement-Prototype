=== Secrets Scan ===
Date: 2026-02-07_21-11-21

Checking for hardcoded secrets...
⚠️  Found 45 potential secrets (review manually)
/home/ern42/CLionProjects/aegisbpf/src/tweetnacl_safe.hpp: * @param sk Secret key (64 bytes)
/home/ern42/CLionProjects/aegisbpf/src/sha256.hpp:bool parse_sha256_token(const std::string& text, std::string& hex);
/home/ern42/CLionProjects/aegisbpf/src/tweetnacl.h:#define crypto_sign_SECRETKEYBYTES 64
/home/ern42/CLionProjects/aegisbpf/src/utils.cpp:    // Check 4: Signed token (for future signed break-glass)
/home/ern42/CLionProjects/aegisbpf/src/utils.cpp:    // Token validation will be implemented in Phase 3 with crypto support
/home/ern42/CLionProjects/aegisbpf/src/utils.cpp:    if (std::filesystem::exists(kBreakGlassTokenPath, ec) && !ec) {
/home/ern42/CLionProjects/aegisbpf/src/commands_policy.cpp:    SecretKey secret_key{};
/home/ern42/CLionProjects/aegisbpf/src/commands_policy.cpp:    for (size_t i = 0; i < secret_key.size(); ++i) {
/home/ern42/CLionProjects/aegisbpf/src/commands_policy.cpp:        secret_key[i] = static_cast<uint8_t>((hi << 4) | lo);
/home/ern42/CLionProjects/aegisbpf/src/commands_policy.cpp:    auto bundle_result = create_signed_bundle(policy_content, secret_key, version, 0);
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:constexpr size_t kSecretKeySize = 64;
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp: * Ed25519 secret key.
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:using SecretKey = std::array<uint8_t, kSecretKeySize>;
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp: * @return Pair of (public_key, secret_key) or error
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:Result<std::pair<PublicKey, SecretKey>> generate_keypair();
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp: * @param secret_key Ed25519 secret key
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:Result<Signature> sign_message(const std::string& message, const SecretKey& secret_key);
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp: * @param secret_key Ed25519 secret key
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:Result<Signature> sign_bytes(const uint8_t* data, size_t data_len, const SecretKey& secret_key);
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp: * @param secret_key Signing key
/home/ern42/CLionProjects/aegisbpf/src/crypto.hpp:Result<std::string> create_signed_bundle(const std::string& policy_content, const SecretKey& secret_key,
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:Result<std::pair<PublicKey, SecretKey>> generate_keypair()
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    SecretKey sk{};
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:Result<Signature> sign_message(const std::string& message, const SecretKey& secret_key)
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    return sign_bytes(reinterpret_cast<const uint8_t*>(message.data()), message.size(), secret_key);
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:Result<Signature> sign_bytes(const uint8_t* data, size_t data_len, const SecretKey& secret_key)
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    if (crypto_safe::crypto_sign_detached_safe(sig.data(), data, data_len, secret_key.data()) != 0) {
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:Result<std::string> create_signed_bundle(const std::string& policy_content, const SecretKey& secret_key,
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    // Get public key from secret key
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    std::memcpy(public_key.data(), secret_key.data() + 32, 32);
/home/ern42/CLionProjects/aegisbpf/src/crypto.cpp:    auto sig_result = sign_message(sign_str, secret_key);
/home/ern42/CLionProjects/aegisbpf/src/commands_monitoring.cpp:    std::string token;
/home/ern42/CLionProjects/aegisbpf/src/commands_monitoring.cpp:        token.push_back(json[pos]);
/home/ern42/CLionProjects/aegisbpf/src/commands_monitoring.cpp:    if (token.empty()) {
/home/ern42/CLionProjects/aegisbpf/src/commands_monitoring.cpp:    return parse_uint64(token, out);
/home/ern42/CLionProjects/aegisbpf/src/policy.cpp:            if (!parse_sha256_token(expected_hash, expected_hash)) {
/home/ern42/CLionProjects/aegisbpf/src/types.hpp:inline constexpr const char* kBreakGlassTokenPath = "/etc/aegisbpf/break_glass.token";
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:bool parse_sha256_token(const std::string& text, std::string& hex)
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    std::string token;
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    if (!(iss >> token)) {
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    if (token.size() != 64) {
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    if (!std::all_of(token.begin(), token.end(), [](unsigned char c) { return std::isxdigit(c); })) {
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    std::transform(token.begin(), token.end(), token.begin(),
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    hex = token;
/home/ern42/CLionProjects/aegisbpf/src/sha256.cpp:    return parse_sha256_token(line, hash);
